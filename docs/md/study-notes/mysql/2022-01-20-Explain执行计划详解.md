---
title: Explain执行计划详解
tags:
  - MySQL
permalink: '/posts/4661f345.html'
date: 2022-01-20 00:00:00
updated: 2022-01-20 00:00:00
---

# Explain执行计划详解

> 作者：IT王小二
>
> 博客：[https://itwxe.com](https://itwxe.com/) 

一条查询 SQL 语句为什么会执行很慢？执行的时候走了什么索引？多表查询的时候 SQL 大体执行流程是怎么样的？Explain执行计划详解给各位客官一一道来。

## 示例MySQL安装方式和版本

首先需要 MySQL 安装的客官看这两篇，小二演示使用的是 Docker 的安装方式：

- [Linux(CentOS7)下二进制安装MySQL5.7.26](https://itwxe.com/posts/b1846d73.html)
- [Docker搭建MySQL并挂载数据](https://itwxe.com/posts/53489f6d.html)

小二安装完的 MySQL 数据库版本为 `5.7.36`。

## Explain工具简介

通常我们在生产环境会碰到查询速度比较慢的 SQL 语句，那么怎么知道 SQL 语句为什么执行慢呢？这个时候就需要用到 Explain 执行计划来分析我们的语句了。

通过使用 Explain 关键字可以模拟优化器执行 SQL 查询语句，执行会返回执行计划的信息，而不是执行这条SQL，当然如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中 。

总的来说，通过 Explain 从而知道 MySQL 是如何处理你的 SQL 语句的，分析查询语句或是表结构的性能瓶颈。那么我们通过 Explain 执行计划可以知道：

- 表的读取顺序
- 数据读取操作的操作类型
- 哪些索引可能被使用
- 哪些索引实际被使用
- 表之间的引用
- 每张表估计有多少行会被执行

Explain文档官方地址：[https://dev.mysql.com/doc/refman/5.7/en/explain-output.html](https://dev.mysql.com/doc/refman/5.7/en/explain-output.html)

## 本文用到的示例表

```sql
CREATE TABLE `author` (
  `id` int(11) NOT NULL,
  `name` varchar(45) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `author` (`id`, `name`, `update_time`) VALUES (1,'itwxe','2022-01-12 19:27:18'), (2,'admin','2022-01-12 19:27:18'), (3,'superAdmin','2022-01-12 19:27:18');

CREATE TABLE `blog` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(10) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_title` (`title`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `blog` (`id`, `title`) VALUES (1,'blog1'),(2,'blog2'),(3,'blog3');

CREATE TABLE `author_blog` (
  `id` int(11) NOT NULL,
  `author_id` int(11) NOT NULL,
  `blog_id` int(11) NOT NULL,
  `remark` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_author_blog_id` (`author_id`,`blog_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `author_blog` (`id`, `author_id`, `blog_id`) VALUES (1,1,1),(2,2,1),(3,1,2);
```

## Explain的变种

Explain 的语法非常简单，只需要在查询语句前面加一个 `EXPLAIN` 关键字即可。

```sql
explain select * from author where id = 1;
```

![explain语法示例](https://images.itwxe.com/images/2022/01/5b2cf031a6fae.png)

如果你发现你的版本少了 `partitions` 或者 `filtered` 列字段信息的话，那是因为在 MySQL5.7 的某个小版本之前的版本是没有这两个字段的。`rows * filtered/100` 可以**估算**出将要和 explain 中前一个表进行连接的行数(前一个表指 explain 中的 id 值比当前表 id 值小的表)。

那么低版本想要看到这两个字段也是有办法的，这就是小二说的 **Explain 的两个变种**。

- **explain extended**：会在低版本 MySQL explain 的基础上额外提供一些查询优化的信息 filtered 列。
- **explain partitions**：会在低版本 MySQL explain 的基础上额外提供一个 partitions 字段，如果查询是基于分区表的话，会显示查询将访问的分区。

在 explain 紧随其后执行的 `show warnings` 命令可以得到优化之后的查询语句，从而看到优化器优化了什么东西，当然优化后的 SQL 并不一定符合 SQL的语法，但是 MySQL 可以识别并可以执行。

![MySQL优化后的语句](https://images.itwxe.com/images/2022/01/a2432f3d82d62.png)

## Explain中的列

###  id

### select_type

### table

### type

### possible_keys

### key

### key_len

### ref

### rows

### Extra

## 常见优化十原则

