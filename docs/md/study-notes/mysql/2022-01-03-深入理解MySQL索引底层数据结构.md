---
title: 深入理解MySQL索引底层数据结构
tags:
  - MySQL
permalink: '/posts/94e3caef.html'
date: 2022-01-03 00:00:00
updated: 2022-01-03 00:00:00
---

# 深入理解MySQL索引底层数据结构

> 作者：IT王小二
> 
> 博客：[https://itwxe.com](https://itwxe.com/) 

MySQL 索引相关的数据结构有两种，一种是 B+tree，一种是 Hash，那么为什么在 99.99% 的情况下都使用的是 B+tree索引呢？

索引的底层数据结构是怎样的呢？

接下来就听小二娓娓道来。

## 索引是什么

MySQL 官方对索引的定义：**索引**是帮助 MySQL 高效获取数据的**排好序**的**数据结构**。

所以，可以得出：**索引是数据结构**！

当然啦，上面两句话可能看起来很抽象，那么生活中有哪些索引的例子呢。

![金瓶梅目录结构](https://images.itwxe.com/images/2022/01/59649a04f487e.png)

小二以上图《金瓶梅》这本为例，书籍的目录就是按顺序排列的，有第一章，第二章...，这就是一种排好序的数据结构。

目录可以快速帮助我们通过页数快速定位到我们想看的章节，比如我们想看《金瓶梅》第三章，翻到第55页...

![流鼻血](https://images.itwxe.com/images/emoji/流鼻血-1.png)

小孩子不能看《金瓶梅》哈，不然就会像小二一样流鼻血，哈哈哈。

那比如复杂一点，想要去图书馆找《金瓶梅》这本书的时候。

![图书馆图书结构](https://images.itwxe.com/images/2022/01/ea8c8d9cdf5e1.png)

图书馆往往会给书籍分类存放，索引是由一个个节点组成，根节点(图书馆)有中间节点(每个楼层的类别)，中间节点下面又由子节点(每楼的每一排的类别)，最后一层是叶子节点(具体书籍)。 

可以看到，索引其实就是是一棵倒挂着的树，是一种**数据结构**。

小二同时附上一个可视化数据结构网站，有了它学习数据结构简单明了。

可视化数据结构网站：[https://www.cs.usfca.edu/~galles/visualization/Algorithms.html](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

![可视化数据结构网站](https://images.itwxe.com/images/2022/01/efc683bb82cff.png)

国外的网站访问略慢，当然你好不容易进去了问小二为啥不是中文，那当然是因为小二点了一下翻译啦。

## 二叉树系列

先来简单说一说和 B+tree 相关的二叉树系列：二叉树、二叉查找树和平衡二叉树

### 二叉树

> 什么是二叉树嘞？
>
> - 每个节点至多只有二棵子树，左子树和右子树，次序不能颠倒。
> - 逻辑上二叉树有五种基本形态：空二叉树、只有一个根结点的二叉树、只有左子树、只有右子树、完全二叉树(特例为满二叉树)。
> - 遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次，有前序、中序、后序遍历。

不过，小二不会大篇幅讲二叉树的各种形态，遍历...，这篇滴主角可是 B+tree。

当然啦，这个时候就有客官要跳出来了，小二明明就是不精通数据结构，还说的这么好听。

哈哈哈，看破不说破嘛，当然也有这方面的原因，大学学习的数据结构全部还给可爱的老师啦。

等小二拜读完《数据结构与算法之美》再出一期数据结构专题，现在就随便看看画的两个图将就一下吧，结构还是比较简单的。

![二叉树](https://images.itwxe.com/images/2022/01/07e5b62d8c16a.png)

由于数据库索引是要求**排好序**的**数据结构**，所以二叉树是不满足使用场景的，那么为了解决**排好序**这个问题，那么就引出了二叉查找树。

### 二叉查找树

> 什么是二叉查找树嘞？
>
> - 二叉查找树又名二叉搜索树，在满足二叉树的条件下，左子树的节点值总是小于根的节点值，右子树的节点值总是大于根的节点值，也就是左子树节点值 < 根的节点值 < 右子树节点值。

如下图的设计，将一组数据转化为二叉查找树，设计合理的二叉查找树查找一个节点数据时间复杂度和二分查找一样。

![设计合理二叉查找树](https://images.itwxe.com/images/2022/01/38e0614782b23.png)

但是如果设计不合理会设计成什么样子呢？

设计不良极不平衡时，二叉搜索树甚至会变成顺序查找，而不是二分查找，如下图所示，同样一个数组最后设计出来的二叉查找树。

![设计不合理二叉查找树](https://images.itwxe.com/images/2022/01/3cf15ffcde2f4.png)

可以看到，在查找 69 和这个数据时，在第一张图中，构建合理的二叉查找树只需要 2 次 IO 就能找到数据；而第二张图中，构建出来的极不平衡二叉查找树需要 6 次磁盘 IO 才能找到数据。

所以，二叉搜索树解决了数据库索引**排好序**的原则，但是二叉查找树构建可能极不平衡，最后构建成了一个链表，这时候就需要用到平衡二叉树了，也就是我们平常说的 AVL树。

### 平衡二叉树(AVL树)

> 什么是平衡二叉树嘞？
>
> - 首先符合二叉查找树的定义，其次必须满足任何节点的两个子树的高度之差的绝对值不超过 1。

上面这句话就很好理解了，也就是说在这个条件下保证了二叉查找树的平衡性，类似于下图结构。

![平衡二叉树](https://images.itwxe.com/images/2022/01/6739525c70ab3.png)

平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。

平衡二叉树的查询速度的确很快，但是维护一棵平衡二叉树的代价是非常大的。通常来说，需要 1 次或多次左旋和右旋来得到插入、更新和删除后树的平衡性。

同时平衡二叉树随着数据的增多，平衡二叉树树的高度会越来越高，大概 1000 条数据就有 9 - 10 层，那也就是说可能找一个数据需要 9 -10 次 IO。

一般来说，一般的机械磁盘每秒至少可以做 100 次 IO，一次 IO 的时间基本上在 0.01 秒，也就是说 1000 条数据在查找时就需要 0.1 秒，那如果是 10000 条，1000000条呢。

所以，为了解决平衡二叉树高度过高导致的 IO 问题，提出了 B-tree 和 B+tree 数据结构。

## B-tree和B+tree



### B-tree



### B+tree



## Hash表



## InnoDB索引实现



## MyISAM索引实现



## 二级索引及联合索引实现



