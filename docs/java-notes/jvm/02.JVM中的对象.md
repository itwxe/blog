---
title: JVM中的对象
permalink: '/java-notes/jvm/1e06d641.html'
date: 2020-05-05 00:00:00
---

# JVM中的对象

> 作者：IT王小二
>
> 博客：[https://itwxe.com](https://itwxe.com)

## 一、对象的创建过程

检查加载 -> 分配内存 -> 内存空间初始化 -> 设置 -> 对象的初始化

### 1. 检查加载

**虚拟机遇到一条new指令时**，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那么必须先执行相应的类加载过程。

### 2. 分配内存

根据方法区的信息确定为该类分配的内存空间大小。

**但是分配内存时主要注意两个问题**

1、如何分配空间

- 指针碰撞：假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”(Bump the Pointer)。
- 空闲列表：如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”(Free List)。

选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

2、修改指针时如何实现线程安全

- 同步处理：对分配内存的空间动作进行同步处理（采用CAS配上失败重试的方式保证跟新操作的原子性）。
- 本地线程分配缓冲：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，叫 **本地线程分配缓冲**，哪个线程需要分配内存，就在那个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。

### 3. 内存空间初始化

**注意不是构造方法**

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如 int 值为 0，boolean 值为 false 等等)。这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

### 4. 设置

接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象的对象头之中。

### 5. 对象初始化

- 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。
- 但从 Java 程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行 new 指令之后会接着把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

## 二、对象的内存分布

在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

1、对象头

- 对象头包括两部分信息，第一部分是 **Mark Word**，用于存储对象自身的运行时数据，如哈希码（HashCode）、GC 标志、对象分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。
- 对象头的另外一部分是 **类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

2、实例数据

实例数据是对象真正存储的有效信息：代码中定义的各种类型的字段内容（包含父类继承的和子类定义的，都需要记录下来）。

3、对齐填充

**对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用**。

由于 HotSpot VM 的自动内存管理系统要求对对象的大小必须是 8 字节的整数倍,所以当对象其他数据部分（对象实例数据）没有对齐时，就需要通过对齐填充来补全。

例如：对象头大小为8字节，实例数据为5字节，那么实例数据就需要通过对齐填充来将实例数据补全成8字节。

## 三、对象的访问定位

建立对象是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针两种。

![对象的定位访问](https://minio.itwxe.com/img/blog/1e06d641_166463962514996.png)

1、句柄：Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

2、直接指针：如果使用直接指针访问， reference 中存储的直接就是对象地址。

3、对比

- 这两种对象访问方式各有优势，使用句柄来访问的最大好处就是 reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。
- 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本，对 Sun HotSpot 而言，它是使用直接指针访问方式进行对象访问的。

## 四、堆内存的分配策略

### 1. 堆进一步划分

- 新生代（PSYoungGen）
    - Eden区
    - From Survivor区（form区）
    - To Survivor区（to区）
- 老年代（ParOldGen）

**注：** 设置两个 Survivor 区是为了解决碎片化的问题（复制回收算法）。

**一些分配规则**

- 新生代和老年代的内存分配比例大概为1:2 。
- 新生代默认分配比例是8:1:1，可以通过下面参数改变。
    - -XX:SurvivorRatio=8 // 默认的8:1:1 。
    - -XX:SurvivorRatio=2 // 设置比例为2:1:1 。

**堆的大小可以通过如下参数设置**

- -Xms20m // 设置堆初始大小20MB
- -Xmx20m // 设置堆最大的大小20MB
- -Xmn10m // 设置年轻代大小10MB

### 2. 分配策略

1、对象优先在Eden分配。

大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间分配时，虚拟机将发起一次 Minor GC。

2、大对象直接进入老年代。

- 虚拟机提供参数-XX：PretenureSizeThreshold参数（这个参数只在serial和ParNew起作用），当对象比这个值大，就直接存入老年代
- 最典型的大对象是那种很长的字符串以及数组。这样做的目的：1.避免大量内存复制,2.避免提前进行垃圾回收，明明内存有空间进行分配。

3、长期存活的对象将进入老年代。

如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1，对象在 Survivor 区中每熬过一次 Minor GC，年龄就增加1，当它的年龄增加到一定程度(默认为15)时，就会被晋升到老年代中。

4、动态对象年龄判定

如果在 Survivor 空间中相同年龄所有对象大小的综合大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。

5、空间分配担保

- 在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。
- 如果不成立，则虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。
- 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。
- 如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的，如果担保失败则会进行一次 Full GC 。
- 如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 Full GC 。

## 五、jvm是怎么实现泛型的

Java 语言中的泛型，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type，也称为裸类型）了，并且在相应的地方插入了强制转型代码，因此，对于运行期的 Java 语言来说，ArrayList＜int＞与 ArrayList＜String＞就是同一个类，所以泛型技术实际上是 Java 语言的一颗语法糖，Java 语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。

举例说明：

```java
public class Jvm3 {

    public static void main(String[] args) {
        Map<String,String> map = new HashMap<>();
        map.put("SunnyBear","22");
        System.out.println(map.get("SunnyBear"));
    }
}
```

经过 javac 编译成.class文件后，使用反编译工具查看会发现泛型都不见了，变成了原生类型。

```java
public class Jvm3 {

    public static void main(String[] args) {
        Map<String, String> map = new HashMap();
        map.put("SunnyBear", "22");
        System.out.println((String)map.get("SunnyBear"));
    }
}
```